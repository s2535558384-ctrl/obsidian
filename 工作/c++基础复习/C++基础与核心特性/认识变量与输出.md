1.在计算机中数据都是按照二进制存储的，一个字节是8bit，在实际项目中，根据变量占用的内存大小,去查看原始数据,可以帮助查找错误。
附一张如何访问计算机中变量的图
![](assets/认识变量与输出/file-20251130171528301.png)

2.首先要认识到c++是一个静态语言，也是一个强类型语言，不同于javascrepit对于类型的检查是很严格的。提到了类型那么就会延申到一个类型变量的声明和初始化。
延申知识点: std:: boolalpha 可以将true/flase输出至控制台上
3.目前作用域的概念以及理解的差不多了，对于存储区还要更深一步的了解。
1. **代码区（Code Segment/Text Segment）**：
    - 存储程序执行代码（即机器指令）的内存区域。这部分内存是共享的，只读的，且在程序执行期间不会改变。
    - 举例说明：当你编译一个C++程序时，所有的函数定义、控制结构等都会被转换成机器指令，并存储在代码区。
2. **全局/静态存储区（Global/Static Storage Area）**：
    - 存储全局变量和静态变量的内存区域。这些变量在程序的整个运行期间都存在，但它们的可见性和生命周期取决于声明它们的作用域。
    - 举例说明：全局变量（在函数外部声明的变量）和静态变量（使用`static`关键字声明的变量，无论是在函数内部还是外部）都会存储在这个区域。
3. **栈区（Stack Segment）**：
    - 存储局部变量、函数参数、返回地址等的内存区域。栈是一种后进先出（LIFO）的数据结构，用于存储函数调用和自动变量。
    - 举例说明：在函数内部声明的变量（不包括静态变量）通常存储在栈上。当函数被调用时，其参数和局部变量会被推入栈中；当函数返回时，这些变量会从栈中弹出，其占用的内存也随之释放。
4. **堆区（Heap Segment）**：
    - 由程序员通过动态内存分配函数（如`new`和`malloc`）分配的内存区域。堆区的内存分配和释放是手动的，因此程序员需要负责管理内存，以避免内存泄漏或野指针等问题。
    - 举例说明：当你使用`new`操作符在C++中动态分配一个对象或数组时，分配的内存就来自堆区。同样，使用`delete`操作符可以释放堆区中的内存。
5. **常量区（Constant Area）**：
    - 存储常量（如字符串常量、const修饰的全局变量等）的内存区域。这部分内存也是只读的，且通常在程序执行期间不会改变。
    - 举例说明：在C++中，使用双引号括起来的字符串字面量通常存储在常量区。此外，使用`const`关键字声明的全局变量，如果其值在编译时就已确定，也可能存储在常量区。
4.那么对于代码如何变成可执行的程序的过程也需要理解记忆。
C++程序的编译过程是一个相对复杂但有序的过程，它涉及将高级语言（C++）代码转换为机器可以执行的低级指令。在这个过程中，通常会生成几个中间文件，包括`.i`（预处理文件）、`.s`（汇编文件）和`.o`（目标文件或对象文件）。下面是这个过程的详细解释：

#### [](https://gitee.com/secondtonone1/boostasio-learn/blob/master/base/document/02-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E5%92%8C%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86.md#1-%E9%A2%84%E5%A4%84%E7%90%86preprocessing)1. 预处理（Preprocessing）

- **输入**：C++源代码文件（通常以`.cpp`或`.cxx`为后缀）。
- **处理**：预处理器（通常是`cpp`）读取源代码文件，并对其进行宏展开、条件编译、文件包含（`#include`）等处理。
- **输出**：生成预处理后的文件，通常具有`.i`后缀（尽管这个步骤可能不是所有编译器都会自动生成`.i`文件，或者可能需要特定的编译器选项来生成）。

#### [](https://gitee.com/secondtonone1/boostasio-learn/blob/master/base/document/02-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E5%92%8C%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86.md#2-%E7%BC%96%E8%AF%91compilation)2. 编译（Compilation）

- **输入**：预处理后的文件（如果有的话，否则直接是源代码文件）。
- **处理**：编译器（如`g++`、`clang++`等）将预处理后的文件或源代码文件转换为汇编语言代码。这个步骤是编译过程的核心，它执行词法分析、语法分析、语义分析、中间代码生成、代码优化等任务。
- **输出**：生成汇编文件，通常具有`.s`或`.asm`后缀。

#### [](https://gitee.com/secondtonone1/boostasio-learn/blob/master/base/document/02-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E5%92%8C%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86.md#3-%E6%B1%87%E7%BC%96assembly)3. 汇编（Assembly）

- **输入**：汇编文件。
- **处理**：汇编器（如`as`、`gas`等）将汇编语言代码转换为机器语言指令（即目标代码），但这些指令仍然是针对特定架构的，并且尚未被链接成可执行文件。
- **输出**：生成目标文件（或对象文件），通常具有`.o`、`.obj`或`.out`后缀。

#### [](https://gitee.com/secondtonone1/boostasio-learn/blob/master/base/document/02-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E5%92%8C%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86.md#4-%E9%93%BE%E6%8E%A5linking)4. 链接（Linking）

- **输入**：一个或多个目标文件，以及可能需要的库文件（如C++标准库）。
- **处理**：链接器（如`ld`、`lld`等）将目标文件和库文件合并成一个可执行文件或库文件。在这个过程中，链接器会解决外部符号引用（即函数和变量的调用），并将它们链接到正确的地址。
- **输出**：生成可执行文件（在Unix-like系统中通常是`.out`、`.exe`或没有特定后缀，在Windows系统中是`.exe`）。
